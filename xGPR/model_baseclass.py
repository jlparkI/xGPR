"""Describes the ModelBaseclass from which other model classes inherit.

The ModelBaseclass describes class attributes and methods shared by
model classes like xGPModel.
"""
import sys
try:
    import cupy as cp
except:
    pass
import numpy as np

from .kernels import KERNEL_NAME_TO_CLASS
from .constants import constants



class ModelBaseclass():
    """The base class for xGPR model classes. Provides shared
    methods and attributes.

    Attributes:
        kernel_choice (str): The kernel selected by the user.
        kernel: The kernel object for the posterior predictive mean. The class of
            this object will depend on the kernel specified by the user -- e.g.
            the 'rbf' kernel corresponds to class Rbf.
        weights: A 1d array, either a cp.ndarray or np.ndarray depending on the
            device specified by the user (cpu or gpu). The random features
            generated by self.kernel are multiplied against the weights to
            generate the posterior predictive mean. The weights are calculated
            during fitting.
        var: A 2d square array, either a cp.ndarray or np.ndarray depending on
            the device specified by the user (cpu or gpu), or a preconditioner
            object for certain kernels (e.g. linear). The random features
            are used in conjunction with var to generate the posterior predictive
            variance. The var is calculated during fitting. Used by regression
            classes only.
        device (str): One of "gpu", "cpu". The user can update this as desired.
            All predict / tune / fit operations are carried out using the
            current device.
        num_rffs (int): The number of random Fourier features used.
        variance_rffs (int): The number of random Fourier features used for
            calculating posterior predictive variance.
        kernel_specific_params (dict): Contains kernel-specific parameters --
            e.g. 'matern_nu' for the nu for the Matern kernel, or 'conv_width'
            for the conv1d kernel.
        verbose (bool): If True, regular updates are printed during
            hyperparameter tuning and fitting.
        num_threads (int): The number of threads to use for random feature generation
            if running on CPU. If running on GPU, this argument is ignored.
        double_precision_fht (bool): If True, use double precision during FHT for
            generating random features. For most problems, it is not beneficial
            to set this to True -- it merely increases computational expense
            with negligible benefit -- but this option is useful for testing.
            Defaults to False.
        exact_var_calculation (bool): If True, variance is calculated exactly (within
            the limits of the random feature approximation). If False, a preconditioner
            is used. The preconditioner approach is only used for certain kernels (e.g.
            linear).
        random_seed (int): The seed to the random number generator. Used throughout the
            model class whenever randomness is desired. Can be reset by user.
            Resetting the random seed -- like changing the number of rffs -- will
            cause the kernel to be re-initialized.
    """

    def __init__(self, num_rffs = 256, variance_rffs = 16,
                    kernel_choice="RBF", device = "cpu",
                    kernel_specific_params = constants.DEFAULT_KERNEL_SPEC_PARMS,
                    verbose = True,
                    num_threads = 2,
                    random_seed = 123):
        """Constructor.

        Args:
            num_rffs (int): The number of random Fourier features
                to use. For certain kernels (Linear) this will be set
                by the data.
            variance_rffs (int): The number of random Fourier features
                to use for posterior predictive variance (i.e. calculating
                uncertainty on predictions). Defaults to 64.
            kernel_choice (str): The kernel that the model will use.
                Defaults to 'RBF'. Must be in kernels.kernel_list.
                KERNEL_NAME_TO_CLASS.
            device (str): Determines whether calculations are performed on
                'cpu' or 'gpu'. The initial entry can be changed later
                (i.e. model can be transferred to a different device).
                Defaults to 'cpu'.
            kernel_specific_params (dict): Contains kernel-specific parameters --
                e.g. 'matern_nu' for the nu for the Matern kernel, or 'conv_width'
                for the conv1d kernel.
            verbose (bool): If True, regular updates are printed
                during fitting and tuning. Defaults to True.
            num_threads (int): The number of threads to use for random feature generation
                if running on CPU. If running on GPU, this argument is ignored.
            random_seed (int): The seed to the random number generator.
        """
        self.kernel_choice = kernel_choice
        self.kernel = None
        self.weights = None
        # Classification classes don't use var or trainy_mean, trainy_std
        self.var = None
        self.trainy_mean = 0
        self.trainy_std = 1

        self.device = device

        self.num_rffs = num_rffs
        #Variance_rffs must be <= num_rffs. Always set second
        self.variance_rffs = variance_rffs

        self.kernel_spec_parms = kernel_specific_params
        self.num_threads = num_threads

        self.verbose = verbose

        # Currently we do not allow user to set double_precision_fht --
        # only used for testing.
        self.double_precision_fht = False
        # Classification classes don't use exact_var
        self.exact_var_calculation = True
        self.random_seed = random_seed




    def pre_prediction_checks(self, input_x, get_var):
        """Checks input data to ensure validity.

        Args:
            input_x (np.ndarray): A numpy array containing the input data.
            get_var (bool): Whether a variance calculation is desired.

        Returns:
            x_array: A cupy array (if self.device is gpu) or a reference
                to the unmodified input array otherwise.

        Raises:
            ValueError: If invalid inputs are supplied,
                a detailed ValueError is raised to explain.
        """
        x_array = input_x
        if self.kernel is None or self.weights is None:
            raise ValueError("Model has not yet been successfully fitted.")
        if not self.kernel.validate_new_datapoints(input_x):
            raise ValueError("The input has incorrect dimensionality.")
        #This should never happen, but just in case.
        if self.weights.shape[0] != self.kernel.get_num_rffs():
            raise ValueError("The size of the weight vector does not "
                    "match the number of random features that are generated.")
        if self.var is None and get_var:
            raise ValueError("Variance was requested but suppress_var "
                    "was selected when fitting, meaning that variance "
                    "has not been generated.")
        if self.device == "gpu":
            mempool = cp.get_default_memory_pool()
            mempool.free_all_blocks()
            x_array = cp.asarray(input_x)

        return x_array


    def set_hyperparams(self, hyperparams = None, dataset = None):
        """Sets the hyperparameters to those supplied if
        the kernel already exists, creates a kernel if it
        doesn't already exist. If the kernel doesn't already
        exist a dataset needs to be supplied to tell the
        kernel what size its inputs will be. If hyperparams is None,
        the kernel is initialized.

        Args:
            hyperparams (ndarray): A numpy array such that shape[0] == the number of
                hyperparameters for the selected kernel.
            dataset: Either None or a valid dataset object. If the kernel already
                exists (i.e. if set hyperparams or any of the tuning / fitting /
                scoring routines has already been called) no dataset is required
                and this argument is ignored. If the kernel does NOT exist,
                this argument is required.

        Raises:
            ValueError: A ValueError is raised if the kernel does not exist but
                a dataset was not supplied.
        """
        if self.kernel is None and dataset is None:
            raise ValueError("A dataset is required if the kernel has not already "
                    "been initialized. The kernel is initialized by calling set_hyperparams "
                    "or fit or any of the hyperparameter tuning / scoring routines.")
        if hyperparams is None and dataset is None:
            raise ValueError("Should supply hyperparams and/or a dataset.")
        if self.kernel is None:
            self._initialize_kernel(dataset, hyperparams = hyperparams)
        else:
            self.kernel.check_hyperparams(hyperparams)
            self.kernel.set_hyperparams(hyperparams, logspace = True)
            self.weights = None
            self.var = None


    def get_hyperparams(self):
        """Simple helper function to return hyperparameters if the model
        has already been tuned or fitted."""
        if self.kernel is None:
            return None
        return self.kernel.get_hyperparams()



    def _initialize_kernel(self, dataset = None, xdim = None,
            hyperparams = None, bounds = None):
        """Selects and initializes an appropriate kernel object based on the
        kernel_choice string supplied by caller. The kernel is then moved to
        the appropriate device based on the 'device' supplied by caller
        and is returned.

        Args:
            dataset: Either None or a valid dataset object. If None, xdim must not be
                None.
            xdim: Either None or the numpy array returned by dataset.get_xdim(). If None,
                dataset must not be None.
            hyperparams (ndarray): Either None or a numpy array. If not None,
                must be a numpy array such that shape[0] == the number of hyperparameters
                for the selected kernel. The kernel hyperparameters are then initialized
                to the specified value. If None, default hyperparameters are used which
                should then be tuned.
            bounds (np.ndarray): The bounds on hyperparameter
                tuning. Must have an appropriate shape for the
                selected kernel. If None, the kernel will use
                its defaults. Defaults to None.

        Returns:
            kernel: An object of the appropriate kernel class.

        Raises:
            ValueError: Raises a value error if an unrecognized kernel
                is supplied.
        """
        if self.kernel_choice not in KERNEL_NAME_TO_CLASS:
            raise ValueError("An unrecognized kernel choice was supplied.")

        if dataset is None and xdim is not None:
            input_xdim = xdim
        elif dataset is not None:
            input_xdim = dataset.get_xdim()
        else:
            raise ValueError("Either a dataset or xdim must be supplied.")

        self.kernel = KERNEL_NAME_TO_CLASS[self.kernel_choice](input_xdim,
                            self.num_rffs, self.random_seed, self.device,
                            self.num_threads, self.double_precision_fht,
                            kernel_spec_parms = self.kernel_spec_parms)
        if bounds is not None:
            self.kernel.set_bounds(bounds)
        if hyperparams is not None:
            self.kernel.check_hyperparams(hyperparams)
            self.kernel.set_hyperparams(hyperparams, logspace = True)
        self.weights, self.var = None, None


    def _run_pre_nmll_prep(self, dataset, bounds = None, nmll_rank = None):
        """Runs key steps / checks needed if about to calculate
        NMLL.
        """
        dataset.device = self.device
        if self.kernel is None:
            self._initialize_kernel(dataset, bounds = bounds)
        self.weights, self.var = None, None
        if nmll_rank is not None:
            if nmll_rank >= self.kernel.get_num_rffs():
                raise ValueError("NMLL rank must be < the number of rffs.")

        return self.kernel.get_bounds()


    def _run_singlepoint_nmll_prep(self, dataset, exact_method = False):
        """Runs key steps / checks needed if about to calculate
        NMLL at a single point, in which case bounds are not needed.
        """
        dataset.device = self.device
        if self.kernel is None:
            self._initialize_kernel(dataset)

        self.weights, self.var = None, None

        if self.num_rffs <= 2:
            raise ValueError("num_rffs should be > 2 to use any tuning method.")

        if exact_method:
            if self.kernel.get_num_rffs() > constants.MAX_CLOSED_FORM_RFFS:
                raise ValueError(f"At most {constants.MAX_CLOSED_FORM_RFFS} can be used "
                        "for tuning hyperparameters using this method. Try tuning "
                        "using approximate nmll instead.")


    def _run_post_nmll_cleanup(self, dataset, hyperparams = None):
        """Runs key steps / checks needed if just finished
        calculating NMLL.
        """
        dataset.device = "cpu"
        if hyperparams is not None:
            self.kernel.set_hyperparams(hyperparams, logspace=True)



    def _run_pre_fitting_prep(self, dataset, max_rank = None):
        """Runs key steps / checks needed if about to fit the
        model.
        """
        dataset.device = self.device
        self.trainy_mean = dataset.get_ymean()
        self.trainy_std = dataset.get_ystd()

        if self.kernel is None:
            self._initialize_kernel(dataset)
        if self.variance_rffs > self.kernel.get_num_rffs():
            raise ValueError("The number of variance rffs should be <= the number "
                    "of random features for the kernel.")
        if max_rank is not None:
            if max_rank < 1:
                raise ValueError("Invalid value for max_rank.")
            if max_rank >= self.kernel.get_num_rffs():
                raise ValueError("Max rank should be < the number of rffs.")


    def _run_post_fitting_cleanup(self, dataset):
        """Runs key steps / checks needed if just finished
        fitting the model.
        """
        dataset.device = "cpu"



    ####The remaining functions are all getters / setters.


    @property
    def kernel_spec_parms(self):
        """Property definition for the kernel_spec_parms."""
        return self._kernel_spec_parms

    @kernel_spec_parms.setter
    def kernel_spec_parms(self, value):
        """Setter for kernel_spec_parms. If the
        user is changing this, the kernel needs to be
        re-initialized."""
        if not isinstance(value, dict):
            raise ValueError("Tried to set kernel_spec_parms to something that "
                    "was not a dict!")
        self._kernel_spec_parms = value
        self.kernel = None
        self.weights = None
        self.var = None


    @property
    def kernel_choice(self):
        """Property definition for the kernel_choice attribute."""
        return self._kernel_choice

    @kernel_choice.setter
    def kernel_choice(self, value):
        """Setter for the kernel_choice attribute. If
        the user is changing this, the kernel needs to
        be re-initialized."""
        if not isinstance(value, str):
            raise ValueError("You supplied a kernel_choice that is not a string.")
        if value not in KERNEL_NAME_TO_CLASS:
            raise ValueError("You supplied an unrecognized kernel.")
        self._kernel_choice = value
        self.kernel = None
        self.weights = None
        self.var = None

    @property
    def num_rffs(self):
        """Property definition for the num_rffs attribute."""
        return self._num_rffs

    @num_rffs.setter
    def num_rffs(self, value):
        """Setter for the num_rffs attribute. If the
        user is changing this, the kernel needs to
        be re-initialized."""
        self._num_rffs = value
        if self.kernel is not None:
            self._initialize_kernel(xdim = self.kernel.get_xdim(),
                   hyperparams = self.kernel.get_hyperparams(),
                   bounds = self.kernel.get_bounds())
        self.weights = None
        self.var = None

    @property
    def variance_rffs(self):
        """Property definition for the variance_rffs attribute."""
        return self._variance_rffs

    @variance_rffs.setter
    def variance_rffs(self, value):
        """Setter for the variance_rffs attribute. If the
        user is changing this, the kernel may need to
        be re-initialized, at least if variance has already
        been calculated. Need to be careful here, because
        for certain fitting procedures, the fit() routine
        does reset variance_rffs."""
        if value > constants.MAX_VARIANCE_RFFS:
            raise ValueError("Currently to keep computational expense at acceptable "
                    f"levels variance rffs is capped at {constants.MAX_VARIANCE_RFFS}.")
        if value > self.num_rffs and self.kernel_choice not in ["Linear", "ExactQuadratic"]:
            raise ValueError("variance_rffs must be <= num_rffs.")
        self._variance_rffs = value
        if self.var is not None:
            if self.kernel is not None:
                self._initialize_kernel(xdim = self.kernel.get_xdim(),
                    hyperparams = self.kernel.get_hyperparams(),
                    bounds = self.kernel.get_bounds())
            self.weights = None
            self.var = None


    @property
    def num_threads(self):
        """Property definition for the num_threads attribute."""
        return self._num_threads

    @num_threads.setter
    def num_threads(self, value):
        """Setter for the num_threads attribute."""
        if value < 1:
            self._num_threads = 1
            raise ValueError("Num threads if supplied must be an integer > 1.")
        self._num_threads = value
        if self.kernel is not None:
            self.kernel.num_threads = value

    @property
    def double_precision_fht(self):
        """Property definition for the double_precision_fht attribute."""
        return self._double_precision_fht


    @double_precision_fht.setter
    def double_precision_fht(self, value):
        """Setter for the double_precision_fht attribute."""
        self._double_precision_fht = value
        if self.kernel is not None:
            self.kernel.double_precision = value

    @property
    def random_seed(self):
        """Property definition for the random_seed attribute."""
        return self._random_seed


    @random_seed.setter
    def random_seed(self, value):
        """Setter for the random_seed attribute. If this is
        reset the kernel needs to be re-initialized."""
        self._random_seed = value
        if self.kernel is not None:
            self.kernel.double_precision = value
        if self.kernel is not None:
            self._initialize_kernel(xdim = self.kernel.get_xdim(),
                   hyperparams = self.kernel.get_hyperparams(),
                   bounds = self.kernel.get_bounds())
        self.weights = None
        self.var = None


    @property
    def device(self):
        """Property definition for the device attribute."""
        return self._device

    @device.setter
    def device(self, value):
        """Setter for the device attribute."""
        if value not in ["cpu", "gpu"]:
            raise ValueError("Device must be in ['cpu', 'gpu'].")

        if "cupy" not in sys.modules and value == "gpu":
            raise ValueError("You have specified the gpu fit mode but CuPy is "
                "not installed. Currently CPU only fitting is available.")

        if "cuda_rf_gen_module" not in sys.modules and value == "gpu":
            raise ValueError("You have specified the gpu fit mode but the "
                "cudaHadamardTransform module is not installed / "
                "does not appear to have installed correctly. "
                "Currently CPU only fitting is available.")

        if self.kernel is not None:
            self.kernel.device = value
        if self.weights is not None:
            if value == "gpu":
                self.weights = cp.asarray(self.weights)
            elif value == "cpu" and not isinstance(self.weights, np.ndarray):
                self.weights = cp.asnumpy(self.weights)
        if self.var is not None:
            if self.exact_var_calculation:
                if value == "cpu":
                    self.var = cp.asnumpy(self.var)
                else:
                    self.var = cp.asarray(self.var)
            else:
                self.var.device = value
        if value == "gpu":
            mempool = cp.get_default_memory_pool()
            mempool.free_all_blocks()
        self._device = value
